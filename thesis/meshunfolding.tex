% Copyright (C) 2014-2019 by Thomas Auzinger <thomas@auzinger.name>

\documentclass[draft,final]{vutinfth} % Remove option 'final' to obtain debug information.

% Load packages to allow in- and output of non-ASCII characters.
\usepackage{lmodern}        % Use an extension of the original Computer Modern font to minimize the use of bitmapped letters.
\usepackage[T1]{fontenc}    % Determines font encoding of the output. Font packages have to be included before this line.
\usepackage[utf8]{inputenc} % Determines encoding of the input. All input files have to use UTF8 encoding.

% Extended LaTeX functionality is enables by including packages with \usepackage{...}.
\usepackage{amsmath}    % Extended typesetting of mathematical expression.
\usepackage{amssymb}    % Provides a multitude of mathematical symbols.
\usepackage{mathtools}  % Further extensions of mathematical typesetting.
\usepackage{microtype}  % Small-scale typographic enhancements.
\usepackage[inline]{enumitem} % User control over the layout of lists (itemize, enumerate, description).
\usepackage{multirow}   % Allows table elements to span several rows.
\usepackage{booktabs}   % Improves the typesettings of tables.
\usepackage{subcaption} % Allows the use of subfigures and enables their referencing.
\usepackage[ruled,linesnumbered,algochapter]{algorithm2e} % Enables the writing of pseudo code.
\usepackage[usenames,dvipsnames,table]{xcolor} % Allows the definition and use of colors. This package has to be included before tikz.
\usepackage{nag}       % Issues warnings when best practices in writing LaTeX documents are violated.
\usepackage{todonotes} % Provides tooltip-like todo notes.

\usepackage{subcaption} 

\usepackage{color}
%%%%%%%%%%%%%%%%%%%%% needed for tikz figures
\usepackage{standalone}
\usepackage{tikz}
\usetikzlibrary{shapes.geometric, arrows}
\usetikzlibrary{calc}
\usepackage{rotating}

\tikzset{block/.style = {rectangle, thick, minimum width=3cm, minimum height=1cm, text centered, text width=3cm, draw=black}}
\tikzset{io/.style = 	{trapezium, trapezium left angle=70, trapezium right angle=-70, trapezium stretches=true, thick, minimum width=3cm, minimum height=1cm, text centered, text width=3cm, draw=black}}
\tikzset{arrow/.style = {thick,->,>=stealth}}
%%%%%%%%%%%%%%%%%%%%%

\usepackage{hyperref}  % Enables cross linking in the electronic document version. This package has to be included second to last.
\usepackage[acronym,toc]{glossaries} % Enables the generation of glossaries and lists fo acronyms. This package has to be included last


% Define convenience functions to use the author name and the thesis title in the PDF document properties.
\newcommand{\authorname}{Thorsten Korpitsch} % The author name without titles.
\newcommand{\thesistitle}{3D Mesh Unfolding} % The title of the thesis. The English version should be used, if it exists.

% Set PDF document properties
\hypersetup{
    pdfpagelayout   = TwoPageRight,           % How the document is shown in PDF viewers (optional).
    linkbordercolor = {Melon},                % The color of the borders of boxes around crosslinks (optional).
    pdfauthor       = {\authorname},          % The author's name in the document properties (optional).
    pdftitle        = {\thesistitle},         % The document's title in the document properties (optional).
    pdfsubject      = {Subject},              % The document's subject in the document properties (optional).
    pdfkeywords     = {unfolding, 3d meshunfolding} % The document's keywords in the document properties (optional).
}

\setpnumwidth{2.5em}        % Avoid overfull hboxes in the table of contents (see memoir manual).
\setsecnumdepth{subsection} % Enumerate subsections.

\nonzeroparskip             % Create space between paragraphs (optional).
\setlength{\parindent}{0pt} % Remove paragraph identation (optional).

\makeindex      % Use an optional index.
\makeglossaries % Use an optional glossary.
%\glstocfalse   % Remove the glossaries from the table of contents.

% Set persons with 4 arguments:
%  {title before name}{name}{title after name}{gender}
%  where both titles are optional (i.e. can be given as empty brackets {}).
\setauthor{}{\authorname}{}{male}
\setadvisor{Ph.D.}{Hsiang-Yun Wu}{}{female}

% For bachelor and master theses:
%\setfirstassistant{Pretitle}{Forename Surname}{Posttitle}{male}
%\setsecondassistant{Pretitle}{Forename Surname}{Posttitle}{male}
%\setthirdassistant{Pretitle}{Forename Surname}{Posttitle}{male}

% For dissertations:
%\setfirstreviewer{Pretitle}{Forename Surname}{Posttitle}{male}
%\setsecondreviewer{Pretitle}{Forename Surname}{Posttitle}{male}

% For dissertations at the PhD School and optionally for dissertations:
%\setsecondadvisor{Pretitle}{Forename Surname}{Posttitle}{male} % Comment to remove.

% Required data.
\setregnumber{01529243}
\setdate{01}{03}{2019} % Set date with 3 arguments: {day}{month}{year}.
\settitle{\thesistitle}{3D Mesh Unfolding} % Sets English and German version of the title (both can be English or German). If your title contains commas, enclose it with additional curvy brackets (i.e., {{your title}}) or define it as a macro as done with \thesistitle.
\setsubtitle{}{} % Sets English and German version of the subtitle (both can be English or German).

% Select the thesis type: bachelor / master / doctor / phd-school.
% Bachelor:
\setthesis{bachelor}
%
% Master:
%\setthesis{master}
%\setmasterdegree{dipl.} % dipl. / rer.nat. / rer.soc.oec. / master
%
% Doctor:
%\setthesis{doctor}
%\setdoctordegree{rer.soc.oec.}% rer.nat. / techn. / rer.soc.oec.
%
% Doctor at the PhD School
%\setthesis{phd-school} % Deactivate non-English title pages (see below)

% For bachelor and master:
\setcurriculum{Media Informatics and Visual Computing}{Medieninformatik und Visual Computing} % Sets the English and German name of the curriculum.

% For dissertations at the PhD School:
%\setfirstreviewerdata{Affiliation, Country}
%\setsecondreviewerdata{Affiliation, Country}

\begin{document}

\frontmatter % Switches to roman numbering.
% The structure of the thesis has to conform to
%  http://www.informatik.tuwien.ac.at/dekanat

\addtitlepage{naustrian} % German title page (not for dissertations at the PhD School).
\addtitlepage{english} % English title page.
\addstatementpage

\begin{danksagung*}
Ich möchte mich bei meiner Beraterin Ph.D. Hsiang-Yun Wu bedanken, dass sie mich in das Thema 3D-Netzfaltung eingeführt hat und mir unermüdlich mit Rat, Tat und Anleitung zur Seite stand. Insbesondere möchte ich ihr auch dafür danken, dass sie mir 3D-Modelle zur Verfügung gestellt hat, um meinen in dieser Arbeit beschriebenen Ansatz zu evaluieren. 

Außerdem möchte ich mich bei meinen Eltern, Ingrid und Horst Korpitsch, sowie bei meiner Großmutter Erna Kaiper und meiner Freundin Valentina Bone bedanken, dass sie mich auch in schwierigen Zeiten immer unterstützt und ermutigt haben. Ohne ihre ewige Geduld, Unterstützung und Motivation wäre diese Arbeit nicht möglich gewesen.

Ich möchte auch Nils Voß MSc für das Korrekturlesen dieser Arbeit danken.
\end{danksagung*}

\begin{acknowledgements*}
I want to thank my addvisor Ph.D. Hsiang-Yun Wu for introducing me to the topic of 3D-Mesh Unfolding and tirelessly providing me with advice, action and guidance. I especially also want to thank her for providing me with prepared 3D-Models to evaluate my approach described in this thesis. 

Furthermore I want to thank my parents, Ingrid and Horst Korpitsch, as well as my grandmother Erna Kaiper and my girlfriend Valentina Bone for always supporting and ecouraging me even in hard times. Without their everlasting patience, support and motivation this thesis would not have been possible.

I also want to thank Nils Voß MSc for proofreading this thesis.
\end{acknowledgements*}

\begin{kurzfassung}
3D Mesh Unfolding ist der Prozess der Transformation des 3D Netzes in eine planare Form. Ein Einsatzgebiet für diesen Prozess ist die Kunst des Papierhandwerks. Während des Prozesses können zwei große Probleme auftreten. Erstens können sich aufgefaltene Flächen überlappen, was es unmöglich macht, es in einem Stück auszuschneiden und zu rekonstruieren. Zweitens dürfen die Flächen beim Entfalten nicht verzerrt werden, denn das würde die Rekonstruktion des originalen Modells unmöglich machen. Diese Arbeit konzentriert sich auf das Hinzufügen von Klebstellen an den Begrenzungskanten, die die Rekonstruktion erleichtern, da sie dem Benutzer Platz zum Auftragen von Klebstoff bietet. 
Ein minimaler Spannbaum, des Dualgraphen, des ursprünglichen Netzes wird berechnet, um das Netz zu entfalten und eine Entfaltung zu finden. Vorberechnete Gluetags werden dann auch für einen Teil der Begrenzungskanten entfaltet, um die Menge der benötigten Gluetags zu minimieren. Mit dem Hinzufügen von Klebstellen werden Überlappungen zwischen Klebstellen, Überlappungen zwischen Flächen und Klebstellen, wahrscheinlicher und es müssen mehr Fälle von Überlappungen erkannt und gelöst werden. Ein simulierter Glühalgorithmus optimiert die Entfaltung, um eine überlappungsfreie Entfaltung zu finden.
\end{kurzfassung}

\begin{abstract}
3D Mesh Unfolding is the process of transforming the 3D Mesh into a 2D planar patch. A field of use for this process is the art of papercraft. During the process, two major problems can arise. Firstly unfolded faces overlap each other, which makes it impossible to create a single cutout. Secondly, during unfolding, the faces must not be distorted, because that would defeat the purpose of reconstructing the original model. This thesis focuses on the addition of glue tags at boundary edges making the reconstruction easier, as it gives users space to apply glue. 
A spanning tree of the dual graph of the original mesh is calculated to unfold the mesh to find an unfolding. Precalculated gluetags are then also unfolded for some of the boundary edges to minimize the amount of gluetags needed. With the addition of glue tags overlaps between glue tags, overlaps between faces and glue tags, become more likely and more cases of overlaps need to be detected and resolved. A simmulated annealing process optimizes the unfolding, to find an unfolding without any overlaps.
\end{abstract}

% Select the language of the thesis, e.g., english or naustrian.
\selectlanguage{english}

% Add a table of contents (toc).
\tableofcontents % Starred version, i.e., \tableofcontents*, removes the self-entry.

% Switch to arabic numbering and start the enumeration of chapters in the table of content.
\mainmatter

\chapter{Introduction}

\section{Background}
The focus in papercraft lies within the creation of 3D models from paper or paper-like material. The models that are created range from simple ones, like paper aeroplanes, to elaborate models of buildings or districts for planning. Further it can be used in combination with self-folding materials to form structures after printing the planar patch. It is a complex task due to two kinds of conflicts that appear in the unfolding process. Distortion of the model, as well as faces overlapping each other, are problems that occur when unfolding a 3D Mesh whereas both should be avoided to allow authentic reconstruction.

\section{Motivation}
As the reconstruction of a model can be quite tricky, even with indicators helping with glueing the right faces together, like the solution presented by Takahashi et al.
~\cite{takahashi2011optimized}, glueing the faces together if they are tiny is still a hard task.
The task of adding Gluetags, which can improve the reconstruction experience, has not been well explored as most of the previous work focused on finding ways to get qualitative unfoldings. The addition of Gluetags makes the problem more difficult as the solution space for a solution without overlaps gets smaller, whereas the search space of possible unfoldings and possible Gluetag positions grows.

\section{Goal}
The goal of this thesis is to explore the viability of adding Gluetags to the cut Edges. Glue tags are to be calculated for the 3D-Model and will be unfolded in the same way as triangles of the Mesh. An simple algorithm will be suggested that can find an overlap-free unfolding for the 3D-Model with Gluetags attached. To find an overlap-free Unfolding, an algorithm to detect Overlaps will be constructed, to detect Overlaps between Faces of the triangles and Gluetags, as well as Faces and other Faces or Gluetags and other Gluetags.
The Overlaps will be resolved by using simulated annealing to find a global optimum. Each step of the Unfolding Process will be visualized. Users will be able to interact with the 3D-Model and the final planar Patch. Furthermore, the performance and the limitations of the approach will be evaluated.

\section{Results}
The suggested approach can generate good results, but is limited by the number of triangles that a model consists of. Meshes with lower than 200 triangles are unfolded consistently without any overlaps remaining. Experiments have shown clear constraints if meshes have more than 700 triangles, which sharply increase of iterations necessary to find an unfolding, which are also not achieved consistently.

\section{Structure}
In Chapter \ref{chap:relatedwork} previous findings related to 3D-Mesh unfolding are discussed and the differences to this approach are highlighted. Also the optimization approach of simulated annealing will be introduced. Chapter \ref{chap:definitions} defines the concepts of Dualgraphs and Minimum Spanning Trees and furthermore will describe the way the data is structured, once it is loaded into the program. Chapter \ref{chap:methodology} will explain the theoretical approach of the steps necessary to unfold 3D-Meshes. Chapter \ref{chap:Implementation} will bring more detail into the implementation of the before explained approach. In Chapter \ref{chap:reseval} the detailed results of this thesis will be discussed. Also the performance, its limitations and tuning of parameters will be explained in detail. Chapter \ref{chap:conclusion} summarises the findings and gives an outlook on future work to improve.

\chapter{Related Work}
\label{chap:relatedwork}

\section{3D-Mesh Unfolding}
According to Takahashi et al.~\cite{takahashi2011optimized} unfolding 3D-Meshes, more concrete polyhedron models, into a single patch is still a well-known open problem. In their paper they have proposed a heuristic approach using a genetic-based algorithm to find distortion free unfoldings. The key concept is to use topological surgerry to construct models through stitch together boundary edges of the unfolded mesh.

Straub et al.~\cite{straubcreating} explored the unfolding and calculating gluetags to an unfolded mesh, in which they also explorer the removal of overlaps introducing new subdivisions to the mesh. As in the previous mentioned paper, a heuristic approach is used to calculate possible unfoldings. They use a greedy algorithm to optimize the cut out and to resolve overlaps. Gluetags that have been calculated to an unfolding are optimized after an unfolding is found.

Chang et al.~\cite{xi2016learning} have focused their work to unfold orthogonal polyhedra. They propose algorithms to unfold 1-layer orthogonal polyhedra by introducing additional cuts depending on their genus. Their main concept is to find a subset of faces, that traverses the surface of the polyhedron, to unfold it along its line. 

There are also a lot of other papers mostly exploring a theoretical approach of unfolding meshes with focuses on different areas, deploying sophisticated algorithms with the focus. Other papers focus on different kind of models. Yet the focus on the reconstruction experience has been neglected. In this thesis I want to focus on explorin the addition of gluetags to triangulated polyhedral meshes. They should help users in the reconstruction effort to glue cut edges together, as well as give a better indication of which edges should be glued together. Therefore a simpler approach to calculating unfoldings using a minimum spanning tree approached, optimized by simulated annealing.

\section{Simulated Annealing}
\label{sec:sa}
Simulated Annealing is a well known optimization process~\cite{kirkpatrick1983optimization}. It can be used to solve combinatorial probelms, that central to computer science and engineering, like mesh unfolding. The main goal is to find a minimum or a maximum vlaue of a function, which is called the cost function, that has many independet variables. An usual examples for the application of this process is the traveling salesman problem, where the most effective route between different cities needs to be found. To solve NP-complete problems, like the traveling salesman problem, heuristic methods are used to solve them.
Simulated Annealing is an iterative process that starts in a state $P$. For this state the cost function is calculated and saved. In each iteration the configuration of state $P$ will be rearranged to a state $P'$, for wich the cost function is calculated again. If the solution is to find a minimized cost, then if $P' < P$ then the next iteration will be calculated frorm the new state $P'$. If the new configuration has a worse cost than the old one, the new configuration is discarded, and a new configuration will be calculated from $P$. This process could lead to a the configuration getting stuck in a local minimum. The iterations are continued until a before chosen temperature $T$ reaches a defined minimum $T_{min}$, which simulates the cooling down of the material.

To avoid such a deadlock in each iteration there is a chance that a worse configuration can be accepted. Let $\Delta E = E - E'$ be the difference between the old cost and the cost of the new configuration. If $\Delta E \leq 0$ the new configuration is accepted. If $Delta E > 0$ it is treated probabilistic, the chance of the new configuration to be accepted is $(\Delta E) = exp(-\Delta E / k_B T)$. $k_B$ is the Boltzmann constant and $T$ is the temperature. Now a uniformly distributed random number within the range of $(0,1)$ implements the random part of the algorithm. If it is less than $P(\Delta E)$ the new configuration is accepted, otherwise it is discarded. Since $T$ is decreasing on each iteration, it will become more unlikely to accept a worse configuration the closer the algorithm comes to an end.

Summarising the concept of the simulated annealing process, to be able to solve a problem with it four important ingredients are needed. A concise description of the configuration of a system, a generator to generate random moves, which changes the configuration of the system, a quantitative function evaluating the trade offs fthat have been made and last but not least an annealing schedule of temperatures and length of times for the system to evolve needs to be developed.
\chapter{Definitions}
\label{chap:definitions}

\section{Data}

The original data has to meet the following requirements to be used:
\begin{itemize}
	\item Data needs to be in the Object File Format (.off)\cite{offfile}.
	\item Data is triangulated.
	\item Doubled Vertices have been removed.
	\item Mesh does not have holes.
\end{itemize}

The data is read from a file and saved into the CGAL datastructure Polyhedron\_3~\cite{cgal:eb-19a}. The data structure consists of vertices, edges and facets and an incidence relation on them. Each edge is represented by an halfedge and an opposite halfedge, that points into the opposite direction. This datastructure provides all informations necessary to calculate an unfolding for a given mesh.

\section{Dual Graph}

\begin{figure}
\includestandalone[width=\textwidth]{"graphics/figdualgraph"}
\caption{(black) Shows a graph with undirected edges. (green solid and dotted) Shows the graphs complete dual graph. (green solid) Shows a minimum spanning tree of the dual graph.}{Graph, Dualgraph and Minimum-Spanning-Tree visualized}
\label{fig:dualgraph}
\end{figure}

Let $G_M$ be the graph representation of a mesh, which is defined by it's Vertices $V$ and undirected Edges $E$ between the vertices. $G_{M_d} = (V_d, E_d)$ is called the dual graph of a graph $G_{M_d} = (V,E)$, which can be obtained by calculating a dual vertex $V_d$ in each enclosed facet and an dual edge $E_d$ for every two facets seperated by an edge in $E$ \cite{gross2004handbook}, as seen in Figure \ref{fig:dualgraph}. The dual graph can then be used to find an unfolding, as each facet is connected with an edge to its neighbours. These connected edges can either represent an edge that is cut or an edge that is used for bending. For every graph there is exactly one dual graph that can be calculated.

\section{Minimum Spanning Tree}

Let $G = (V,E)$ be a connected undirected graph with $|V| = n$ vertices and $|E| = m$ edges. Given a value $c(v,w)$ for each edge $(v,w) \in E$, a spanning tree $T = (V,E'), E' \subseteq E$ such that $\sum_{\{v,w\}\in E'} c(v,w)$ is minimal\cite{cheriton1976finding}. A minimum spanning tree is therefore acyclic by definition and can be used to find an unfolding, as an unfolding must not contain cycles. Many simple algorithms for computing minimum spanning trees are available to choose from. To apply a minimum spanning tree algorithm to the mesh unfolding problem, they weights of the edges cannot be a constant value, as it would result in exactly one minimum spanning tree. If this minimum spanning tree doesn't result in an unfolding without faces overlapping each other, another spanning tree needs to be found.

\chapter{Methodology}
\label{chap:methodology}

\section{Overview}

\begin{figure}
\includestandalone[width=\textwidth]{"graphics/figoverview"}
\caption{Overview of the 3D Mesh-Unfolding Process.}
\label{fig:overview}
\end{figure}

After loading a mesh, its dual graph is calculated as a first step, as seen in Figure \ref{fig:overview}, as it is necessary for all later calculations. After that for each edge, two glue tags are calculated, each targeting one facet of the edge and having its source on the other facet. Then the simulated annealing process starts. In each iteration, a new minimum spanning tree is calculated, which is then unfolded. Afterwards overlaps are calculated, if overlaps are found a new minimum spanning tree is calculated. If no overlaps are found, the process ends, as an overlap-free solution has been found. In the following subchapters, each Step is described in more detail, whereas the simulated annealing process is explained in more detail in Chapter \ref{chap:Implementation}.

\section{Calculate Dualgraph}

As the dual graph is calculated from the original mesh, which does not change during the unfolding process, the dual graph is calculated at the beginning once, as shown in Figure \ref{fig:overview}. The neighbourhood relation of the facets can be derived from the half edges connecting the mesh vertices. 

The dual graph is calculated by iterating through all facets of the mesh. For each facet, we need to iterate through the half edges and through the opposite half-edges the neighbouring facet can be identified. These two facets are saved as an edge and can be initialized with the weight of the length of the original half-edge or a random value.

\section{Calculate Gluetag}

The second step in the pipleline shown in Figure \ref{fig:overview} is to calculate gluetags. For each edge of the dual graph a gluetag can be calculated for both facets connected by this edge. The vertices of an edge are the base of a gluetag. As gluetags can vary in shape and size, this thesis proposes gluetags in the shape of a trapezoid as it brings a few advantages. 

A trapezoid is defined by two triangles, therefore algorithms that are applied to triangles of the mesh can be applied to the gluetags without altering them. As the top of the trapezoid is smaller than the base, gluetags that are placed next to each other are less likely to overlap compared to rectangular gluetags. The height of the gluetags is calculated from the facet it targets, so that it takes up a maximum of 20 percent of the targeted facets space.

Gluetags are calculated only once after the dual graph was calculated, as the edges they are linked to do not change. Instead the gluetags will be chosen when deciding a minimum spanning tree. 

\section{Calculate Minimum Spanning Tree}

Entering the simulated annealing loop the first step is to calculate the minimum spanning tree of the dual graph, as shown in Figure \ref{fig:overview}. For this the edges are sorted by their weight in an ascending order. Then we need to iterate through all edges and add each edge to an adjacence list. This list can be used to check if the recently added edge causes the graph to be cyclic. If this is the case, the last edge will be removed and added to a list containing the cut edges, if the graph remained acyclic the edge is added to a list containing the bend edges. 

Furthermore for each iteration we save the information which face has been discovered, so we can assure that the graph is a connected graph as well as acyclic, which is necessary. As a result the adjacence list defines a minimum spanning tree.

\section{Unfolding}
\label{sec:unfold}
Following the calculation of the minimum spanning tree, as shown in Figure \ref{fig:overview}, an unfolding of the mesh is calculated. The adjacence list of the last step can be used to determine the order of the faces for unfolding.

Let $T = (A,B,C)$ be a triangle defined by three vertices $A(x_A, y_A, z_A)$, $B(x_B, y_B, z_B)$ and $C(x_C, y_C, z_C)$, where $x_N$, $y_N$ and $z_N$, with $N \in \{A,B,C\}$, are the coordinates of each vertex. Let $T_p = (a, b, c)$ be the planar representation of the given triangle, defined by $a(x_a, y_a)$, $b(x_b, y_b)$ and $c(x_c, y_c)$, where again $x_n$, $y_n$, with $n \in \{a,b,c\}$, are the defining coordinates of each vertex.

The first face is treated as a special case, as the later triangles depend on the position of the vertices of the first triangle. Let $A$ be the vertices of the first triangle, it can be set to $(0,0)$ disregarding the position of $A$ as it is not relevant. To calculate $b$ we need to calculate the distance $\overline{AB}$ as it is equal to $\overline{ab}$, wich can be calculated using formula \ref{eq:pytha}.

\begin{equation}
\label{eq:pytha}
\overline{AB} = \overline{ab} = \sqrt{(x_A - x_B)^2 + (y_A - y_B)^2 + (z_A - z_B)^2}
\end{equation}

Now $b$ can be set to $(\overline{AB}, 0)$, with $y$ being set to $0$ as the original orientation of the triangle does not need to be retained. The last vertices $c$ is again a special case, as two positions are possible, which will be important for all vertices except the first. Two solutions are possible for $c$, as it can be placed on either side of the vector $(a-b)$. 

\begin{align}
\label{eq:cone}
\begin{split}
s &= \frac{\|(B - A)\times(C - A)\|}{(\overline{AB})^2}\\
d &= \frac{(B-A)\cdot(C-A)}{(\overline{AB})^2}\\
c_x &= a_x + d(b_x - a_x) - s(b_y - a_y)\\
c_y &= a_y + d(b_y - a_y) + s(b_x - a_x)
\end{split}
\end{align}

The first candidate solution for $c_1 = (c_x, c_y)$ is defined by the formulas \ref{eq:cone}. The second candidate solution for $c_2$ can be calculated by the formulas \ref{eq:ctwo}. 

\begin{equation}
\label{eq:ctwo}
\begin{split}
c_x &= a_x + d(b_x - a_x) + s(b_y - a_y)\\
c_y &= a_y + d(b_y - a_y) - s(b_x - a_x)
\end{split}
\end{equation}

For the first triangle any of the two solutions can be chosen. For all other triangles a check needs to be performed, so that $c$ is not on the same side as it is for the previous triangle.


Now let $c_{prev} = (c_{x_{prev}},c_{y_{prev}})$ be the vertex of the previous triangle that it does not share with the current triangle. To calculate the side on which the vertex $c$ has to be put can be determined by the formula \ref{eq:side}.

\begin{equation}
\label{eq:side}
f = (c_x - a_x) * (b_y - a_y) - (c_y - a_y) * (b_x - a_x)
\end{equation}

In theory these formulas can yield three different results $f < 0$ for one side, $f > 0$ for the other side and $f = 0$ if it is on the line. But as we do not have any degenerate triangles in our mesh there are two cases. $f$ needs to be calculated for $c_{prev}$ and for the two solutions of the previous formula $c_1$ and $c_2$. Now we are left with two possibilities, if $f_{prev} < 0$ and $f_{c_1} > 0$ or if $f_{prev} > 0$ and $f_{c_1} < 0$ then we set $c = c_1$, otherwise $c = c_2$.

Unfolding of gluetags works in an analouge way, as the gluetag consists of two triangles, therefore it is left to the reader as an excercise.

\section{Overlap Detection}

The last step of the simulated annealing loop, as shown in Figure \ref{fig:overview}, is to determine the quality of the unfolding. As a meassurement for the quality simply the sum of the overlapping areas is used. Overlaps can happen between triangles, triangles and gluetags or between gluetags. The detection is a two step process, first only the triangles are checked if they overlap each other. In a second step, if no triangles overlap each other, the gluetags are checked if they overlap each other or a triangle. To find out if triangles overlap each other we can check if any of their lines intersect with each other.

Let $T = (A,B,C)$ and $S = (P,Q,R)$ be two triangles that might be overlapping each other, defined by their points $A$, $B$, $C$, $P$, $Q$, $R$. Therefore we check the lines $\overline{AB}$ and $\overline{PQ}$ if they intersect with each other. For two line segments we can define a general case for overlaps and a special case. In general the lines intersect only if the points $(A,B,P)$ and $(A,B,Q)$ have differrent orientations and $(P,Q,A)$ and $(P,Q,B)$ have different orientations.

For the special case the lines intersect, if all four point triplets are collinear and the x-projections of $(A,B)$ and $(P,Q)$ intersect and the y-projections of $(A,B)$ and $(P,Q)$ intersect as well.

These calculations need to be done for every line pair of the two triangles and if any of the line pairs intersect, it means that the triangles intersect each other. The overlap detection does not need to be done with the child of another triangle as they share an edge and therefore cannot overlap, as the child is unfolded onto the other side of the shared edge, as explained in section \ref{sec:unfold}.

\chapter{Implementation}
\label{chap:Implementation}

\section{Specifications}

The prototype system is implemented on an Laptop with an Intel Core i7 CPU (3.3 GHz, 4MB Cache) and 8GB RAM. The source code is written in C++17. The OpenGL Library library is used for the visualization of the algorithms step as well as the results. The CGAL library is used to read in off-Files as well as the basic datastructure. The Graphical User Interface (GUI) is developed using the Qt Library. CMake is used to manage the build process and it is compiled on an Ubuntu 18.04.02 LTS operating system.

\section{Simmulated Annealing}

The four important ingredients to use a simulated annealing process, explained in section \ref{sec:sa}, are defined for the following way.
\begin{itemize}
	\item \textbf{System Description} The system configuration is described as a list of edges that will be bent and the complementary list of edges that are cut. Furthermore the facets attached to the edges, as well as the gluetags attached to some of the cut edges.
	\item \textbf{Random Move} To alter the configuration randomly, a random edge of the full eedge list has its weight changed, therefore the minimum spanning tree that is calculated changes.
	\item \textbf{Quantitive Function} To evaluate the system configuration the sum of the overlapping areas is used.
	\item \textbf{Annealing Schedule} The temperature is set to 50.000 as a standard, but can be configured and the cooling rate is set to 1.0, therefore the temperature equals the amount of iterations.
\end{itemize}

After reading in the mesh into the CGAL Polyhedron\_3 datastructure perperations are necessary to be able to describe the system. First a dual graph is calculated and gluetags are calculated for each edge of the dual graph, as each edge could be a possible cut edge. Furthermore the temperature and the cooling rate are set to 40.000 and 1.0 per iteration, defining the runtime of the annealing process.

An initial configuration of the system is calculated. This happens by assigning each edge of the dual graph a random weight and then sorting the edge list by weight. Using this edge list a initial minimum spanning tree is calculated. Now using the information which edges will be cut, the gluetgas can be calculated. Therefore we iterate through all possible gluetags and choose a gluetag if the following conditions are fulfilled:

\begin{itemize}
	\item The edge the gluetag is attached to is a cut edge
	\item The opposite gluetag was not already added to this edge
	\item The number of cut edges, that have no gluetag yet is higher than 1 or neither the source face for the gluetag nor the the face the gluetag targets have a gluetag yet
\end{itemize}

If these conditions are not fulfilled the gluetag this gluetag will not be considered for this unfolding. These conditions ensure that the reconstructed model will be stable when glued together without faces being loose, but also reducing the number of gluetags to the absolutely necessary amount, to reduce time and effort on reconstruction.

After these two calculations have been made, the triangles and the gluetags will be unfolded. The area of both triangle-triangle overlaps, gluetag-triangle overlaps and gluetag-gluetag overlaps will be calculated. Triangle-triangle overlaps are weighted 100 times higher than gluetag-caused overlaps, since a triangle-triangle overlap-free unfolding is necessary to even pay attention to the overlaps caused by gluetags.

The calculated area is then used as the energy of the graph, which we try to minimize in this process. This initial configuration is then saved as the best configuration. For each following iteration before these steps are repeated a random edge will be chosen and assigned to a new random weight, which possibly changes the outcoming minimum spanning tree. In the iterative generations and evaluation of configurations also the calculation of the energy differs. First the triangles are unfolded and evaluated, if they do not unfold without overlaps, the gluetags are not calculated as no matter if they unfold without errors, the unfolding will already not be overlap free, doing this saves computation time.

If the energy of the new configuration is smaller or equal to the energy of the previous configuration, the new generation will be set as the best configuration. If not the configuration is treated probabilistic. If a uniformly distributed random number smaller than $P(\Delta E) = 1 - e^{-(T + E)/(T_{max})}$, which is calculated for each configuration, therefore decreasing over time as $T$ gets smaller, then the new configuration will be accepted as the best configuration. This condition should ensure that the algorithm cannot get stuck in a local minimum, which would mean that it would not find an optimal global solution.

At the end of every iteration, if a new best configuration was found the new configuration will be visualized using OpenGL, which means that it only changes and impacts calculation time of each iteration, if a better configuration was found. This gives users a better understanding of how the algorithm finds a global solution for the problem.

The annealing process ends if either no overlaps are found or if the temperature reaches the minimum, which means that it ends without finding a solution for this problem. Advantages and Disadvantages using this random walk approach will be discussed in section \ref{sec:limitations}.

\chapter{Results and Evaluation}
\label{chap:reseval}

\section{Results}
The following figures show the resulting unfolding of the implementation. The gluetags are visualized in the 3D-Model and in the unfolding, furthermore the minimum spanning tree (green lines) and cut-edges (red lines) are visualized in the 3D-Model.

\begin{figure}
  \begin{subfigure}[b]{0.5\textwidth}
    \includegraphics[width=\textwidth]{"graphics/unfoldings/model_tiger"}
  \end{subfigure}
  %
  \begin{subfigure}[b]{0.5\textwidth}
    \includegraphics[width=\textwidth]{"graphics/unfoldings/unfold_tiger"}
  \end{subfigure}
  
  \caption{3D Model of a tiger head with 112 faces and the coresponding unfolding.}
  \label{fig:tiger}
\end{figure}

\begin{figure}
  \begin{subfigure}[b]{0.5\textwidth}
    \includegraphics[width=\textwidth]{"graphics/unfoldings/model_sqrt3"}
  \end{subfigure}
  %
  \begin{subfigure}[b]{0.5\textwidth}
    \includegraphics[width=\textwidth]{"graphics/unfoldings/unfold_sqrt3"}
  \end{subfigure}
  
  \caption{3D Model with 72 faces and the coresponding unfolding.}
  \label{fig:sqrt3}
\end{figure}

\begin{figure}
  \begin{subfigure}[b]{0.5\textwidth}
    \includegraphics[width=\textwidth]{"graphics/unfoldings/model_pnsplit"}
  \end{subfigure}
  %
  \begin{subfigure}[b]{0.5\textwidth}
    \includegraphics[width=\textwidth]{"graphics/unfoldings/unfold_pnsplit"}
  \end{subfigure}
  
  \caption{3D Model of a star with 216 faces and the coresponding unfolding.}
  \label{fig:pnsplit}
\end{figure}

\begin{figure}
  \begin{subfigure}[b]{0.5\textwidth}
    \includegraphics[width=\textwidth]{"graphics/unfoldings/model_loop"}
  \end{subfigure}
  %
  \begin{subfigure}[b]{0.5\textwidth}
    \includegraphics[width=\textwidth]{"graphics/unfoldings/unfold_loop"}
  \end{subfigure}
  
  \caption{3D Model of a star with 96 faces and the coresponding unfolding.}
  \label{fig:loop}
\end{figure}

\begin{figure}
  \begin{subfigure}[b]{0.5\textwidth}
    \includegraphics[width=\textwidth]{"graphics/unfoldings/model_butterfly"}
  \end{subfigure}
  %
  \begin{subfigure}[b]{0.5\textwidth}
    \includegraphics[width=\textwidth]{"graphics/unfoldings/unfold_butterfly"}
  \end{subfigure}
  
  \caption{3D Model of a star with 96 faces and the coresponding unfolding.}
  \label{fig:butterfly}
\end{figure}

\begin{figure}
  \begin{subfigure}[b]{0.5\textwidth}
    \includegraphics[width=\textwidth]{"graphics/unfoldings/model_dragon"}
  \end{subfigure}
  %
  \begin{subfigure}[b]{0.5\textwidth}
    \includegraphics[width=\textwidth]{"graphics/unfoldings/unfold_dragon"}
  \end{subfigure}
  
  \caption{3D Model of a dragon with 344 faces and the coresponding unfolding.}
  \label{fig:dragon}
\end{figure}

\begin{figure}
  \begin{subfigure}[b]{0.5\textwidth}
    \includegraphics[width=\textwidth]{"graphics/unfoldings/model_horse"}
  \end{subfigure}
  %
  \begin{subfigure}[b]{0.5\textwidth}
    \includegraphics[width=\textwidth]{"graphics/unfoldings/unfold_horse"}
  \end{subfigure}
  
  \caption{3D Model of a horse with 312 faces and the coresponding unfolding.}
  \label{fig:horse}
\end{figure}

\begin{figure}
  \begin{subfigure}[b]{0.5\textwidth}
    \includegraphics[width=\textwidth]{"graphics/unfoldings/model_hand"}
  \end{subfigure}
  %
  \begin{subfigure}[b]{0.5\textwidth}
    \includegraphics[width=\textwidth]{"graphics/unfoldings/unfold_hand"}
  \end{subfigure}
  
  \caption{3D Model of a hand with 336 faces and the coresponding unfolding.}
  \label{fig:hand}
\end{figure}

\begin{figure}
  \begin{subfigure}[b]{0.5\textwidth}
    \includegraphics[width=\textwidth]{"graphics/unfoldings/model_armadillo"}
  \end{subfigure}
  %
  \begin{subfigure}[b]{0.5\textwidth}
    \includegraphics[width=\textwidth]{"graphics/unfoldings/unfold_armadillo"}
  \end{subfigure}
  
  \caption{3D Model of an armadillo with 386 faces and the coresponding unfolding.}
  \label{fig:armadillo}
\end{figure}

%\newpage

\section{Performance}
\label{sec:performance}

To evaluate the algorithm and its implementation tests were run with a variety of models. The results in table \ref{tbl:performance} were observed using a gluetag that is defined as a trapezoid with the base being the edge of the to-glue triangles and the top being one half of the base with a maximum height of one fifth of the size of the triangle being targeted by the gluetag. The iterations were capped at a maximum of 100000.

\begingroup
\centering
\begin{tabular}{|ll|r|r|}
\hline
Model & & Faces & Time to Unfold (s) \\
\hline
Octa & & 8 & 0 \\
Icosa & & 20 & 0 \\
Star & & 24 & 8 \\
%Sphere-42 & & 42 & - \\
Star-Sqrt3 & (Fig. \ref{fig:sqrt3}) & 72 & 31 \\
Star-4Split & & 96 & 435 \\
Star-Loop & (Fig. \ref{fig:loop}) & 96 & 137 \\
Star-Butterfly & (Fig. \ref{fig:butterfly}) & 96 & 1047 \\
Tiger & (Fig. \ref{fig:tiger}) & 112 & 65 \\
Kitten & & 122 & 48 \\
Moneybox-128 & & 128 & 160 \\
Bunny-128 & & 128 & 103 \\
%Sphere-162 & & 162 & - \\
Moneybox-196 & & 196 & 324 \\
%Star-9Split & & 216 & - \\
Star-PNsplit & (Fig. \ref{fig:pnsplit}) & 216 & 625 \\
Snail-286 & & 286 & 1315 \\
Horse & (Fig. \ref{fig:horse}) & 312 & 946 \\
Hand & (Fig. \ref{fig:hand}) & 336 & 1377 \\
Dragon & (Fig. \ref{fig:dragon}) & 344 & 1292 \\
Bunny-348 & & 348 & 976 \\
Luigi & & 356 & 686 \\
Armadillo & (Fig. \ref{fig:armadillo}) & 386 & 730 \\
Pooh & & 392 & 957 \\
Moneybox-392 & & 392 & 2200 \\
%Seagull & & 462 & - \\
%Knot & & 480 & - \\
%Chess & & 496 & - \\
%Gear & & 508 & - \\
%Bumpy & & 528 & - \\
%Snail-574 & & 574 & - \\
%Cat & & 702 & - \\
%Fish & & 950 & - \\
%Mannequin & & 1376 & - \\
\hline
\end{tabular}
\captionof{table}{Table showing the unfolding performance for different models}\label{tbl:performance}
\endgroup

The performance is not only influced by the number of faces for a model, but also by the size of gluetags. The bigger the gluetags are the more iterations are necessary to find an unfolding, or an unfolding might no longer be possible. Due to the random walk the time to find an unfolding, is not depending on the amount of faces, which can be seen in tabel \ref{tbl:performance} but also depends how and which edges are changed.

\section{Limitations}
\label{sec:limitations}

There are multiple factors that are limitting the presented approach. The target of the approach is to solve the problem only considering the global optimum, disregarding local overlaps, therefore the latter are tough to resolve, as they are not targeted specifically.
Another limitation is that the gluetags that are necessary cannot be calculated beforehand. Neither the amount nor the position of the gluetags can be calculated, without using a heuristic approach or bruteforce, whereas bruteforce is not feasible as the performance even with small models is abysmall.

Another limitation, that can also be helpfull in some cases is the random-walk approach used in the simulated annealing. A random edge is chosen and changed in each iteration, which might not change the minimum spanning tree that is generated. It can happen that an edge that is causing an overlap does not change for many iteration.

\section{Parameterization}

To be able to optimize the algorithm there are multiple parameters that can be tuned, without changing the approach itself.

\textbf{Gluetag size} is the most influential parameter that can be changed. Depending on the size of the gluetag the solution space is widened or made smaller if the gluetags get bigger.

\textbf{Probabilistic treatment of worse iterations} can also be changed to either favor taking a worse iteration more or less often. If the probability is too high to take a worse iteration, the algorithm will not find a solution and might not even get close to a solution. If the probability is too low, the chance of getting stuck in a local optimum increases.

\textbf{Number of iteration} can be controlled by changing the cooling down rate as well as the maximum and minimum temperature, therefore changing the time the algorithm has to find a solution.

By tuning these parameters the results can be influenced to get better performance or make finding an unfolding possible.

\chapter{Conclusion}
\label{chap:conclusion}

\section{Summary}
Calculating an unfolding using a minimum spanning tree approach is possible and can yield good performance for smaller meshes. As meshes grow in size and gluetags get bigger the worse the algorithm is performing. The reconstruction is almost impossible without any visual cues on which edges should be folded or glued first, but disregarding this factor as it can be added with this approach too, a bigger setback is that the unfolding is more or less random and structures of the 3D-Model might not be well conserved into the unfolding. All in all the approach is simple to implement as no sophisticated algorithms are needed and it yields results in an okay amount of time for models with less than 200 faces.

\section{Future Work}
The quality of the unfolding could be improved, by not only meassuring the unfolding by the overlap area but also considering other factors, like keeping structures of the mesh together to help users with reconstructing the models.

To improve performance gluetags could be post processed to change their shape if the overlap area is small. With this improvement the computation time can be reduced significantly, without impacting other parts of the approach.

Once an unfolding with gluetags for a model is found a greedy algorithm could be used to minimize the amount of gluetags necessary. Currently the amount of gluetags is determined by the order the gluetags are added, therefore it can result in using more gluetags than necessary for the particular unfolding.
\backmatter

% Use an optional list of figures.
\listoffigures % Starred version, i.e., \listoffigures*, removes the toc entry.

% Use an optional list of tables.
\cleardoublepage % Start list of tables on the next empty right hand page.
\listoftables % Starred version, i.e., \listoftables*, removes the toc entry.

% Use an optional list of alogrithms.
\listofalgorithms
\addcontentsline{toc}{chapter}{List of Algorithms}

% Add an index.
\printindex

% Add a glossary.
\printglossaries

% Add a bibliography.
\bibliographystyle{alpha}
\bibliography{meshunfolding}

\end{document}
