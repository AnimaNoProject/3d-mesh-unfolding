% Copyright (C) 2014-2019 by Thomas Auzinger <thomas@auzinger.name>

\documentclass[draft,final]{vutinfth} % Remove option 'final' to obtain debug information.

% Load packages to allow in- and output of non-ASCII characters.
\usepackage{lmodern}        % Use an extension of the original Computer Modern font to minimize the use of bitmapped letters.
\usepackage[T1]{fontenc}    % Determines font encoding of the output. Font packages have to be included before this line.
\usepackage[utf8]{inputenc} % Determines encoding of the input. All input files have to use UTF8 encoding.

% Extended LaTeX functionality is enables by including packages with \usepackage{...}.
\usepackage{amsmath}    % Extended typesetting of mathematical expression.
\usepackage{amssymb}    % Provides a multitude of mathematical symbols.
\usepackage{mathtools}  % Further extensions of mathematical typesetting.
\usepackage{microtype}  % Small-scale typographic enhancements.
\usepackage[inline]{enumitem} % User control over the layout of lists (itemize, enumerate, description).
\usepackage{multirow}   % Allows table elements to span several rows.
\usepackage{booktabs}   % Improves the typesettings of tables.
\usepackage{subcaption} % Allows the use of subfigures and enables their referencing.
\usepackage[ruled,linesnumbered,algochapter]{algorithm2e} % Enables the writing of pseudo code.
\usepackage[usenames,dvipsnames,table]{xcolor} % Allows the definition and use of colors. This package has to be included before tikz.
\usepackage{nag}       % Issues warnings when best practices in writing LaTeX documents are violated.
\usepackage{todonotes} % Provides tooltip-like todo notes.

\usepackage{subcaption} 

\usepackage{color}
%%%%%%%%%%%%%%%%%%%%% needed for tikz figures
\usepackage{standalone}
\usepackage{tikz}
\usetikzlibrary{shapes.geometric, arrows}
\usetikzlibrary{arrows.meta}
\usetikzlibrary{calc}
\usepackage{rotating}

\tikzset{block/.style = {rectangle, thick, minimum width=3cm, minimum height=1cm, text centered, text width=3cm, draw=black}}
\tikzset{io/.style = 	{trapezium, trapezium left angle=70, trapezium right angle=-70, trapezium stretches=true, thick, minimum width=3cm, minimum height=1cm, text centered, text width=3cm, draw=black}}
\tikzset{arrow/.style = {thick,->,>=stealth}}
%%%%%%%%%%%%%%%%%%%%%

\usepackage{hyperref}  % Enables cross linking in the electronic document version. This package has to be included second to last.
\usepackage[acronym,toc]{glossaries} % Enables the generation of glossaries and lists fo acronyms. This package has to be included last


% Define convenience functions to use the author name and the thesis title in the PDF document properties.
\newcommand{\authorname}{Thorsten Korpitsch} % The author name without titles.
\newcommand{\thesistitle}{Optimizing 3D Mesh Unfoldings With Additional Gluetags Using Simulated Annealing} % The title of the thesis. The English version should be used, if it exists.

% Set PDF document properties
\hypersetup{
    pdfpagelayout   = TwoPageRight,           % How the document is shown in PDF viewers (optional).
    linkbordercolor = {Melon},                % The color of the borders of boxes around crosslinks (optional).
    pdfauthor       = {\authorname},          % The author's name in the document properties (optional).
    pdftitle        = {\thesistitle},         % The document's title in the document properties (optional).
    pdfsubject      = {unfolding, 3d mesh, meshunfolding, simulated annealiing, gluetags, bachelor thesis},              % The document's subject in the document properties (optional).
    pdfkeywords     = {unfolding, 3d mesh, meshunfolding, simulated annealiing, gluetags} % The document's keywords in the document properties (optional).
}

\setpnumwidth{2.5em}        % Avoid overfull hboxes in the table of contents (see memoir manual).
\setsecnumdepth{subsection} % Enumerate subsections.

\nonzeroparskip             % Create space between paragraphs (optional).
\setlength{\parindent}{0pt} % Remove paragraph identation (optional).

\makeindex      % Use an optional index.
\makeglossaries % Use an optional glossary.
%\glstocfalse   % Remove the glossaries from the table of contents.

% Set persons with 4 arguments:
%  {title before name}{name}{title after name}{gender}
%  where both titles are optional (i.e. can be given as empty brackets {}).
\setauthor{}{\authorname}{}{male}
\setadvisor{Ph.D.}{Hsiang-Yun Wu}{}{female}

% For bachelor and master theses:
%\setfirstassistant{Pretitle}{Forename Surname}{Posttitle}{male}
%\setsecondassistant{Pretitle}{Forename Surname}{Posttitle}{male}
%\setthirdassistant{Pretitle}{Forename Surname}{Posttitle}{male}

% For dissertations:
%\setfirstreviewer{Pretitle}{Forename Surname}{Posttitle}{male}
%\setsecondreviewer{Pretitle}{Forename Surname}{Posttitle}{male}

% For dissertations at the PhD School and optionally for dissertations:
%\setsecondadvisor{Pretitle}{Forename Surname}{Posttitle}{male} % Comment to remove.

% Required data.
\setregnumber{01529243}
\setdate{01}{03}{2019} % Set date with 3 arguments: {day}{month}{year}.
\settitle{\thesistitle}{\thesistitle} % Sets English and German version of the title (both can be English or German). If your title contains commas, enclose it with additional curvy brackets (i.e., {{your title}}) or define it as a macro as done with \thesistitle.
\setsubtitle{}{} % Sets English and German version of the subtitle (both can be English or German).

% Select the thesis type: bachelor / master / doctor / phd-school.
% Bachelor:
\setthesis{bachelor}
%
% Master:
%\setthesis{master}
%\setmasterdegree{dipl.} % dipl. / rer.nat. / rer.soc.oec. / master
%
% Doctor:
%\setthesis{doctor}
%\setdoctordegree{rer.soc.oec.}% rer.nat. / techn. / rer.soc.oec.
%
% Doctor at the PhD School
%\setthesis{phd-school} % Deactivate non-English title pages (see below)

% For bachelor and master:
\setcurriculum{Media Informatics and Visual Computing}{Medieninformatik und Visual Computing} % Sets the English and German name of the curriculum.

% For dissertations at the PhD School:
%\setfirstreviewerdata{Affiliation, Country}
%\setsecondreviewerdata{Affiliation, Country}

\begin{document}

\frontmatter % Switches to roman numbering.
% The structure of the thesis has to conform to
%  http://www.informatik.tuwien.ac.at/dekanat

\addtitlepage{naustrian} % German title page (not for dissertations at the PhD School).
\addtitlepage{english} % English title page.
\addstatementpage

\begin{danksagung*}
Ich möchte mich bei meiner Beraterin Ph.D. Hsiang-Yun Wu bedanken, dass sie mich in das Thema 3D-Netzfaltung eingeführt hat und mir unermüdlich mit Rat, Tat und Anleitung zur Seite stand. Insbesondere möchte ich ihr auch dafür danken, dass sie mir 3D-Modelle zur Verfügung gestellt hat, um meinen in dieser Arbeit beschriebenen Ansatz zu evaluieren. 

Außerdem möchte ich mich bei meinen Eltern, Ingrid und Horst Korpitsch, sowie bei meiner Großmutter Erna Kaiper und meiner besseren Hälfte Valentina Bone bedanken, dass sie mich auch in schwierigen Zeiten immer unterstützt und ermutigt haben. Ohne ihre ewige Geduld, Unterstützung und Motivation wäre diese Arbeit nicht möglich gewesen.

Ich möchte auch Nils Voß MSc für das Korrekturlesen dieser Arbeit danken.
\end{danksagung*}

\begin{acknowledgements*}
I want to thank my advisor, Ph.D. Hsiang-Yun Wu for introducing me to the topic of 3D-Mesh Unfolding and tirelessly providing me with advice, action and guidance. I especially also want to thank her for providing me with prepared 3D-Models to evaluate my approach described in this thesis. 

Furthermore, I want to thank my parents, Ingrid and Horst Korpitsch, as well as my grandmother Erna Kaiper and my better half Valentina Bone for always supporting and encouraging me even in hard times. Without their everlasting patience, support and motivation, this thesis would not have been possible.

I also want to thank Nils Voß MSc for proofreading this thesis.
\end{acknowledgements*}

\begin{kurzfassung}
3D Mesh Unfolding ist der Prozess der Transformation eines 3D Mesh in ein 2D planares Patch. Diese Technik kann verwendet werden, um Papercraft-Modelle zu erstellen, dabei werden 3D-Objekte mit einem Papier oder papierähnlichem Material rekonstruiert werden. Da die Rekonstruktion von Modellen recht knifflig sein kann, benötigen Anwender Indikatoren, welche Flächen miteinander verklebt werden sollen. In dieser Arbeit werden sogenannte Gluetags vorgestellt, die Anwendern Platz geben um Klebstoff aufzutragen, um die Rekonstruktion zu erleichtern. Das Hinzufügen dieser Gluetags erhöht die Schwierigkeit überlappungsfreie Entfaltungen zu finden, die aus einem einzigen Stück Papier ausgeschnitten werden können, um das Modell zu rekonstruieren. Dabei erhöht sich die Anzahl der möglichen Entfaltungen, während der Lösungsraum schrumpft. Ein Minimum Spanning Tree Ansatz wird verwendet, um mögliche Entfaltungen zu berechnen, während simuliertes Glühen verwendet wird, um die Entfaltung zu optimieren und eine Lösung ohne Überlappungen zu finden. Quantitative Experimente deuten darauf hin, dass der vorgeschlagene Ansatz schnelle Ergebnisse für kleinere Netze und auch für größere Netze innerhalb eines größeren Zeitrahmens liefert, diese zeigen aber auch eindeutige Limitationen auf.
\end{kurzfassung}

\begin{abstract}
3D Mesh Unfolding is the process of transforming a 3D mesh into a 2D planar patch. This technique can be used to create papercraft models, where 3D objects get reconstructed using a planar paper or paper-like material. As the reconstruction of models can be quite tricky, users need indicators of which faces should be glued together. Further, in this thesis, Gluetags are introduced, that give users space to apply glue to ease the reconstruction. The addition of these Gluetags increases the difficulty of finding overlap-free unfoldings, that can be cut out of a single piece of paper to reconstruct the model, as the amount of possible unfoldings increases while the solution space shrinks. A minimum spanning tree approach is used to calculate possible unfoldings, whereas simulated annealing is used to optimize the unfolding, to find one without overlaps. Quantitative experiments suggest that the proposed approach can yield fast results for smaller meshes and also results for larger meshes within an increased timeframe, but they also show the limitations of this approach.
\end{abstract}

% Select the language of the thesis, e.g., english or naustrian.
\selectlanguage{english}

% Add a table of contents (toc).
\tableofcontents % Starred version, i.e., \tableofcontents*, removes the self-entry.

% Switch to arabic numbering and start the enumeration of chapters in the table of content.
\mainmatter

\chapter{Introduction}
This chapter gives a brief overview of what papercraft is, and insight on the background of this work. Furthermore, it explains the motivation and goals of this thesis. Lastly, it discusses shortly the results and describes how the following chapters are structured.

\section{Background}
\textit{Papercraft} is a widely popular art of creating two or three-dimensional objects from cardboard or paper. The models that are created range from simple ones, like paper aeroplanes, to elaborate models of buildings or districts for planning. Further, it can be used in combination with self-folding materials to form structures after printing the planar patch. In order to build papercraft models a 3D mesh representing the object needs to be unfolded into a 2D mesh, then this mesh can for example be printed onto paper and then reconstructed into the 3D model. It is a complex task due to two kinds of conflicts that appear in the unfolding process. Distortion of the model, as well as faces overlapping each other, are problems that occur when unfolding a 3D mesh whereas both should be avoided to allow authentic reconstruction.

\section{Motivation}
As the reconstruction of a model can be quite tricky, even with indicators helping with glueing the right faces together, like the solution presented by Takahashi et al.
~\cite{takahashi2011optimized}, glueing the faces together if they are tiny is still a hard task.
To make reconstruction easier this paper introduces \textit{Gluetags}. These Gluetags add small faces on edges that are cut and give user space to apply glue to. Adding Gluetags, which can improve the reconstruction experience, has not been well explored as most of the previous work focused on finding ways to get highly qualitative unfoldings. Attaching Gluetags makes the problem more difficult as the solution space for a solution without overlaps shrinks, whereas the search space of possible unfoldings and possible Gluetag positions increases.

\section{Goal}
The goal of this thesis is to explore the addition of Gluetags to the cut Edges. This thesis proposes the calculation of Gluetags in advance for the 3D-Model before the unfolding process starts. During the unfolding Gluetags are treated as part of the original mesh. Hence there is no need for additional calculations. This thesis proposes a simple spanning tree approach to find unfoldings of the mesh. A simulated annealing process is optimizing the search for an overlap free unfolding by finding an optimal global layout. Steps of the process are visualized and allow users to interact with both the 3D-Model and the final planar patch. At last, the performance and limitations of the proposed approach are evaluated.

\section{Results}
The suggested approach generates results in a limited amount of time. Experiments strongly suggest that the time frame for finding unfoldings increases as meshes increase their number of faces, but also the layout of faces influences the time to find unfoldings. Meshes with less than 200 triangles are unfolded consistently without any overlaps remaining, whereas meshes with up to 400 triangles can be unfolded with an increased timeframe and meshes over 700 faces cannot be resolved. Another limiting factor is the size of Gluetags, which makes finding overlap free unfoldings less likely as Gluetags increase in size. To counteract the increase in time needed for a greater amount of faces, the Gluetag size can be adjusted.

\section{Structure}
First chapter \ref{chap:relatedwork} provides an overview of previous findings related to 3D Mesh Unfolding and highlights differences to the proposed approach in this thesis. It also provides the theoretical background and related work for simulated annealing, that optimizes the search for unfoldings. Chapter \ref{chap:definitions} defines the concepts of dual graphs and minimum spanning trees and further describes the data structure for this approach. The next chapter, \ref{chap:methodology}, gives an overview of the processing pipeline, that calculates an unfolding and describes necessary steps in detail. The next chapter, \ref{chap:Implementation}, brings insight into the implementation of the previously explained approach and focuses on the simulated annealing process. Chapter \ref{chap:reseval} shows the results of the implemented approach and discusses and evaluates its performance and limitations. The last chapter \ref{chap:conclusion} summarises the findings and gives an outlook on future work.

\chapter{Related Work}
\label{chap:relatedwork}
This chapter focuses on previous work that has been done on the topic of optimizing the unfolding of 3D Meshes, but also point out the key differences to the approach proposed in this thesis. Furthermore the optimization technique of simulated annealing is presented.

\section{Optimized Unfolding of 3D Meshes}
According to Takahashi et al.~\cite{takahashi2011optimized} unfolding 3D-Meshes, more concrete polyhedron models, into a single patch is still a well-known open problem. They have proposed a heuristic approach using a genetic-based algorithm to find distortion free unfoldings. The key concept is to use topological surgery to construct models by stitching together boundary edges of the unfolded mesh.

Straub et al.~\cite{straubcreating} explored the unfolding and calculating gluetags to an unfolded mesh, in which they also explore the removal of overlaps by introducing new subdivisions to the mesh. As in the previously mentioned paper, a heuristic approach is used to calculate possible unfoldings. They use a greedy algorithm to optimize the cut out and to resolve overlaps. Gluetags that have been calculated to an unfolding are optimized, i.e. changed in size to fit and non-overlap, after an unfolding is found.

A different approach is proposed by Jun Mitani and Hirosama Suzuki~\cite{mitani2004making}. In their paper, they describe producing unfoldings by using strip-based approximation. They propose segmenting meshes into parts of easily reconstructible segments, which can be done with feature extraction. They add internal cut lines whenever a feature, like a dent in the mesh, is detected on a triangle strip, to make it reconstructible. Due to this simplification they produce a rather large error compared to other simplification methods. Their solution mostly focused on large mesh models where they merged regions between 60 and 250 triangles.

Chang et al.~\cite{xi2016learning} have focused their work to unfold orthogonal polyhedra. They propose algorithms to unfold 1-layer orthogonal polyhedra by introducing additional cuts depending on their genus. Their main concept is to find a subset of faces, that traverses the surface of the polyhedron, to unfold it along its line. 

Theoretical approaches for unfolding meshes have been intensively explored~\cite{shephard1975convex}, while other papers focus on different kind of meshes, for example a lot of papers focus on the unfolding of orthogonal polyhedra \cite{xi2016learning}\cite{damian2007epsilon}\cite{damian2014unfolding}.

Yet the focus on the reconstruction experience has been neglected. This thesis focuses on exploring the addition of Gluetags to triangulated polyhedral meshes. They should help users in the reconstruction effort to glue cut edges together, as well as give a better indication of which edges should be glued together. Therefore a simpler approach to calculating unfoldings using a minimum spanning tree approached, optimized by simulated annealing was selected.

\section{Optimization Techniques}
\label{sec:sa}
As the unfolding of 3D Meshes is considered an NP-complete problem\cite{haenselmann2012optimal} optimization techniques are necessary to minimize the time needed to find a solution. Many optimization techniques are well explored, like greedy algorithms\cite{devore1996some} or heuristic optimization techniques\cite{lee2008modern}. This thesis proposes simulated annealing as the optimization technique for finding an optimal unfolding. Compared to hill climbers, simulated annealing is less likely to get stuck in local optimums, which appear often in problems akin to 3D Mesh Unfolding. Furthermore, simulated annealing is easy to implement and very configurable, as later explained in this section.

\subsection{Simulated Annealing}

Simulated annealing is a well-known optimization process~\cite{kirkpatrick1983optimization} that is widely applicable in problems found in computer science~\cite{goffe1994global}~\cite{dekkers1991global}~\cite{brooks1995optimization} and other scientific fields~\cite{pannetier1990prediction}~\cite{sutter1995automated}. This process tries to emulate the annealing of metal that is being processed.

The main goal is to find an optimal value of a function, which is called the cost function, which has many independent variables. A typical example that simulated annealing is applied to is the travelling salesman problem~\cite{malek1989serial}, where the most effective route between different cities needs to be found. 

Simulated annealing is an iterative process that starts with a system and its configuration $P$. For this configuration, the cost function calculates a value, which is called the energy of the configuration $E$. In each iteration, the configuration $P$ is rearranged to a configuration $P'$, for which the cost function calculates the value $E'$. Let $E' \leq E$ be true, then the new configuration $P'$ replaces $P$ as the base configuration, from which new configurations are arranged. This iteration repeats until a temperature $T$ reaches a defined minimum temperature $T_{min}$, as $T$ cools down in each iteration. When $T$ reaches $T_{min}$ the cost $E$ of configuration $P$ is minimized.

The process has to be extended with another step to counteract the problem of deadlocking, which happens when a configuration $P$ reaches a local minimum, instead of the global one. To avoid such situations, let $\Delta E = E - E'$ be the difference between the energy of the old configuration and the energy of the new configuration. If $\Delta E \leq 0$ holds true  the new configuration is accepted, otherwise if $\Delta E > 0$ the new configuration is treated probabilistic, where the chance of accepting it is $(\Delta E) = exp(-\Delta E / k_B T)$, where $k_B$ is the Boltzmann constant. Now a uniformly distributed random number $R$ within the range of $(0,1)$ implements the random part of the algorithm. If $R < P(\Delta E)$ then the new configuration is accepted. Otherwise, it discards the new configuration. As $T$ decreases over time, it gets more unlikely to accept worse configurations as time passes on and the algorithm nears its end.

To summarize simulated annealing, four essential ingredients are necessary. First, a concise description of the configuration of a system is required. Second, a generator, which generates random moves, that changes the configuration of a system is needed. A quantitative function that evaluates the trade-offs for each iteration needs to be defined. Last but not least, the system can only evolve with an annealing schedule of temperatures and length of times. This evolving process can be stopped with a cooling-rate, which tries to emulate the cooling down of metal, because metal can only be formed while it is hot.


\chapter{Definition of Data and Key Concepts}
\label{chap:definitions}
This chapter describes the properties of the data that is processed in the implementation. It also gives definitions for key concepts used in this thesis.

\section{Data}
The original data has to meet the following requirements to be applicable.

\begin{itemize}
	\item Data is in the Object File Format (.off)
	\item Data is triangulated
	\item Doubled Vertices are removed
	\item Mesh has no holes
	\item All faces are connected
\end{itemize}

\begin{figure}
\includestandalone[width=\textwidth]{"graphics/figcgal"}
\caption{CGAL Polyhedron\_3 datastructure visualized. Adapted from the CGAL user manual~\cite{cgal:eb-19a}.}
\label{fig:cgal}
\end{figure}

The data is read from a file and saved into the CGAL data structure Polyhedron\_3~\cite{cgal:eb-19a}. A Polyhedron\_3 object consists of vertices, edges and facets and an incidence relation on them, as shown in Figure \ref{fig:cgal}. An halfedge and an opposite halfedge, that points into the opposite direction, represent each edge of the mesh. These halfedges consist of vertex pairs that can be accessed. The opposite halfedge links each face to its neighbouring face, also the halfedges are also linked together, therefore enabling iterating through all halfedges of a face. With this data structure, all information is available to apply the approach suggested in this thesis.

\section{Dual Graph}

Let $G_M$ be the graph representation of a mesh, which is defined by its vertices $V$ and undirected edges $E$ between the vertices. $G_{M_d} = (V_d, E_d)$ is called the dual graph of a graph $G_{M_d} = (V,E)$, which can be obtained by calculating a dual vertex $V_d$ in each enclosed facet and an dual-edge $E_d$ for every two facets separated by an edge in $E$ \cite{gross2004handbook}, as seen in Figure \ref{fig:dualgraph}. The dual graph can then be used to find an unfolding, as a dual-edge connects each neighbouring facets. These dual-edges can either represent an edge that is cut or an edge that is used for bending. Therefore the dual graph contains all edges that connects the faces in an unfolding, but also all edges that are cut. A graph has only one dual graph and as the calculation of it can be done very efficient, which makes it a good option to use in 3D mesh unfolding for finding an unfolding.

\begin{figure}
\includestandalone[width=\textwidth]{"graphics/figdualgraph"}
\caption{(black) Shows a graph with undirected edges. (green solid and dotted) Shows the graphs complete dual graph. (green solid) Shows a minimum spanning tree of the dual graph.}
\label{fig:dualgraph}
\end{figure}

\section{Minimum Spanning Tree}

Let $G = (V,E)$ be a connected undirected graph with $|V| = n$ vertices and $|E| = m$ edges. Given a value $c(v,w)$ for each edge $(v,w) \in E$, a spanning tree $T = (V,E'), E' \subseteq E$ such that $\sum_{\{v,w\}\in E'} c(v,w)$ is minimal~\cite{cheriton1976finding}. A minimum spanning tree is therefore acyclic by definition and can be used to find an unfolding, as an unfolding must not contain cycles. Many simple algorithms for computing minimum spanning trees are available~\cite{kruskal1956shortest}~\cite{ahuja1990faster}. 

If the minimum spanning tree is calculated from the dual graph the edges that are part of the minimum spanning tree are the edges that are bent when reconstructing. All other edges not in the minimum spanning tree are edges that are cut. Therefore a minimum spanning tree is due to it's simple calculation a good combination with the dual graph to calculate possible unfoldings. 

As a weighted graph, where no edges have the same weight, have exactly one minimum spanning tree. This is a problem, since the dual graph doesn't inherently have weights to begin with. Weights need to be assigned to each edge of the dual graph. But the weights cannot be constant values, as in the traveling salesman problem, because not all minimum spanning trees will yield an overlap without any overlaps. 
As initial weights the length of the edges of the original graph, that connect the faces with each other, can be used as a weight.

\section{Gluetag}
\begin{figure}
\includestandalone[width=0.8\textwidth]{"graphics/figgluetag"}
\caption{Exemplary trapezoid gluetag (green) attached to its source triangle edge (blue) and the triangle it will be glued to (red).}
\label{fig:gluetag}
\end{figure}

A Gluetag is a space that users can use to apply glue. It can have different forms, for example, a trapezoid shape, as seen in figure \ref{fig:gluetag}. A Gluetag has two positions for each edge, as seen in figure \ref{fig:gluetag}, having one source and one destination edge that can be swapped to point into the other direction, therefore switching the source and target edge. In this thesis, we propose trapezoid-shaped Gluetags that are put on one side of a cut edge at maximum.

\section{Unfolding}
An Unfolding is defined as the 2D representation of the 3D Model, after unfolding. It is created by unfolding faces after each other, according to the minimum spanning tree. The exact order of which face is unfolded first can be neglected as the minimum spanning tree defines exactly one unfolding. The quality of an unfolding in this thesis is defined by the overlapping area since distortion cannot appear due to the algorithm used. An optimal or correct unfolding is therefore defined as an unfolding without distortion of faces and no overlapping areas. 

\chapter{Methodology}
\label{chap:methodology}

\begin{figure}
\includestandalone[width=\textwidth]{"graphics/figoverview"}
\caption{Overview of the 3D Mesh-Unfolding Process.}
\label{fig:overview}
\end{figure}

Figure \ref{fig:overview} gives an overview for the methodology proposed in this thesis. It shows each step from loading a 3D Model to visualizing the resulting unfolded model. After loading a mesh, its dual graph is calculated as a first step, as seen in Figure \ref{fig:overview}, as it is necessary for all later calculations. After that for each edge, two Gluetags are calculated, each targeting one facet of the edge and having its source on the other facet, see Figure \ref{fig:gluetag}. Then the simulated annealing process starts. Each iteration calculates and unfolds a new minimum spanning tree. Afterwards overlaps are calculated, if overlaps are found a new minimum spanning tree is calculated. If no overlaps are found, the process ends, as an overlap-free solution has been found. In the following sub-chapters, each Step is described in more detail, whereas the simulated annealing process is explained in more detail in Chapter \ref{chap:Implementation}.

\section{Calculating the Dualgraph}

As the dual graph is calculated from the original mesh, which does not change during the unfolding process, the dual graph is calculated at the beginning once, as shown in Figure \ref{fig:overview}. The neighbourhood relation of the facets can be derived from the half edges connecting the mesh vertices. 

The dual graph is calculated by iterating through all facets of the mesh. For each facet, we need to iterate through the half edges, where the opposite half-edges are used to identify the neighbouring face. These two facets are saved as an edge and can be initialized with a weight, for example, the length of the original half-edge separating the faces or a random value.

\section{Calculating the Gluetags}

The second step in the pipeline shown in Figure \ref{fig:overview} is to calculate Gluetags. For each edge of the dual graph, a Gluetag is calculated for both facets connected by this edge. The vertices of an edge are the base of a Gluetag. As Gluetags, an example shown in Figure \ref{fig:gluetag}, can vary in shape and size, this thesis proposes Gluetags in the shape of a trapezoid as it brings a few advantages. 

Two triangles define a trapezoid. Therefore algorithms that are applied to triangles of the mesh can be applied to the Gluetags without altering them. As the top of the trapezoid is smaller than the base, Gluetags that are placed next to each other are less likely to overlap compared to rectangular Gluetags. The algorithm calculates the height of the Gluetag depending on the targeted facet so that it takes up a maximum of 20 per cent of the targeted facets space.

Glue tags are calculated once after the dual graph was calculated, as the edges they are linked to do not change. The algorithm chooses the Gluetags based on the calculated minimum spanning tree.

\section{Calculating a Minimum Spanning Tree}

In the first step, as shown in Figure \ref{fig:overview}, the algorithm calculates a minimum spanning tree from the dual graph. This is done using Kruskal's Algorithm~\cite{kruskal1956shortest} to find the shortest spanning subtree.

For this, the edges are sorted by their weight in ascending order. Then the algorithm iterates through all edges and adds each edge to an adjacency list. This list is used to check if the recently added edge causes the graph to be cyclic. If this is the case, the last edge is removed and added to a list containing the cut edges. Otherwise, the edge is added to a list containing the bend edges. Furthermore, for each iteration, we save the information which face is discovered, so we can assure that the graph is a connected graph besides being acyclic, which is necessary. As a result, the adjacency list defines a minimum spanning tree.

To be able to calculate different minimum spanning trees the weights of an edge is changed on each iteration, which is part of the simulated annealing process. Fur further details see chapter \ref{chap:Implementation}.

\section{Unfolding}
\label{sec:unfold}
Following the calculation of the minimum spanning tree, as shown in Figure \ref{fig:overview}, an unfolding of the mesh is calculated. The adjacency list of the last step can be used to determine the order of the faces for unfolding.

Let $T = (A,B,C)$ be a triangle defined by three vertices $A(x_A, y_A, z_A)$, $B(x_B, y_B, z_B)$ and $C(x_C, y_C, z_C)$, where $x_N$, $y_N$ and $z_N$, with $N \in \{A,B,C\}$, are the coordinates of each vertex. Let $T_p = (a, b, c)$ be the planar representation of the given triangle, defined by $a(x_a, y_a)$, $b(x_b, y_b)$ and $c(x_c, y_c)$, where again $x_n$, $y_n$, with $n \in \{a,b,c\}$, are the defining coordinates of each vertex.

The first face is treated as a particular case, as the later triangles depend on the position of the vertices of the first triangle. Let $A$ be the vertices of the first triangle, and it is set to $(0,0)$ disregarding the position of $A$ as it is not relevant. The algorithm calculates $b$ by calculating the distance $\overline{AB}$ as it is equal to $\overline{ab}$, which can be calculated using formula \ref{eq:pytha}.

\begin{equation}
\label{eq:pytha}
\overline{AB} = \overline{ab} = \sqrt{(x_A - x_B)^2 + (y_A - y_B)^2 + (z_A - z_B)^2}
\end{equation}

Now $b$ can be set to $(\overline{AB}, 0)$, with $y$ being set to $0$ as the original orientation of the triangle does not need to be retained. The last vertices $c$ is again a particular case, as two positions are possible, which will be necessary for all vertices except the first. Two solutions are possible for $c$, as it can be placed on either side of the vector $(a-b)$. 

\begin{align}
\label{eq:cone}
\begin{split}
s &= \frac{\|(B - A)\times(C - A)\|}{(\overline{AB})^2}\\
d &= \frac{(B-A)\cdot(C-A)}{(\overline{AB})^2}\\
c_x &= a_x + d(b_x - a_x) - s(b_y - a_y)\\
c_y &= a_y + d(b_y - a_y) + s(b_x - a_x)
\end{split}
\end{align}

The first candidate solution for $c_1 = (c_x, c_y)$ is defined by the formulas \ref{eq:cone}. The second candidate solution for $c_2$ can be calculated by the formulas \ref{eq:ctwo}. 

\begin{equation}
\label{eq:ctwo}
\begin{split}
c_x &= a_x + d(b_x - a_x) + s(b_y - a_y)\\
c_y &= a_y + d(b_y - a_y) - s(b_x - a_x)
\end{split}
\end{equation}

For the first triangle, any of the two solutions can be chosen. For all other triangles a check needs to be performed, so that $c$ is not on the same side as it is for the previous triangle.


Now let $c_{prev} = (c_{x_{prev}},c_{y_{prev}})$ be the vertex of the previous triangle that it does not share with the current triangle. To calculate the side on which the vertex $c$ has to be put can be determined by the formula \ref{eq:side}.

\begin{equation}
\label{eq:side}
f = (c_x - a_x) * (b_y - a_y) - (c_y - a_y) * (b_x - a_x)
\end{equation}

In theory these formulas can yield three different results $f < 0$ for one side, $f > 0$ for the other side and $f = 0$ if it is on the line. But as we do not have any degenerate triangles in our mesh there are two cases. $f$ needs to be calculated for $c_{prev}$ and for the two solutions of the previous formula $c_1$ and $c_2$. Now we are left with two possibilities, if $f_{prev} < 0$ and $f_{c_1} > 0$ or if $f_{prev} > 0$ and $f_{c_1} < 0$ then we set $c = c_1$, otherwise $c = c_2$.

The unfolding of Gluetags works in an analogue way, as the Gluetag consists of two triangles, therefore it is left to the reader as an exercise.

\section{Detecting Overlaps}

The last step of the simulated annealing loop, as shown in Figure \ref{fig:overview}, is to determine the quality of the unfolding. As a measurement for the quality, merely the sum of the overlapping areas is used. Overlaps, as seen in Figure \ref{fig:overlap}, can happen between triangles, triangles and Gluetags or between Gluetags. The detection is a two-step process. First, only the triangles are checked if they overlap each other. In a second step, if no triangles overlap each other, the Gluetags are checked if they overlap each other or a triangle. The algorithm checks if any of their lines intersect with each other to find out if triangles overlap each other.

\begin{figure}
\centering
\begin{subfigure}[t]{.5\textwidth}
	\includestandalone[width=\textwidth]{"graphics/figoverlap"}
  \caption{Two triangles overrlap each other, resulting in a triangle describing the red overlap area.}
	\label{fig:overlap1}
\end{subfigure}%
\begin{subfigure}[t]{.5\textwidth}
	\includestandalone[width=\textwidth]{"graphics/figoverlap2"}
	\caption{Two triangles overlap each other, resulting in a polygon describing the red overlap area.}
	\label{fig:overlap2}
\end{subfigure}
\caption{Overlaps of triangles resulting in different overlapping areas.}
\label{fig:overlap}
\end{figure}

Let $T = (A,B,C)$ and $S = (P,Q,R)$ be two triangles that might be overlapping each other, defined by their points $A$, $B$, $C$, $P$, $Q$, $R$. Therefore we check the lines $\overline{AB}$ and $\overline{PQ}$ if they intersect with each other. For two line segments we can define a general case for overlaps and a special case. In general the lines intersect only if the points $(A,B,P)$ and $(A,B,Q)$ have differrent orientations and $(P,Q,A)$ and $(P,Q,B)$ have different orientations.

For the special case, the lines intersect, if all four point-triplets are collinear and the x-projections of $(A,B)$ and $(P,Q)$ intersect and the y-projections of $(A,B)$ and $(P,Q)$ intersect as well.

The proposed solution calculates for every pair of lines of the two triangles if they intersect. If at least one pair of lines intersect each other, it means that the triangles intersect. The overlap detection does not need to be done with the child of another triangle as they share an edge and therefore cannot overlap, as the child is unfolded onto the other side of the shared edge, as explained in section \ref{sec:unfold}.

\begin{algorithm}
\KwData{Clipping Polygon, Subject Polygon}
\KwResult{List of vertices of the intersection polygon}
List output = Subject Polygon Vertices\;
\While{Edge clipedge in Clipping Polygon}
{
List input = output\;
clear output\;
Point S = input.last()\;
\While{Point E in inputlist}
{
\eIf{E inside clipedge}
{
\If{S not inside clipedge}
{
output.add(ComputeIntersection(S,E,clipedge))\;
}
add E to output\;
}
{
\If{S inside clipedge}
{
output.add(ComputeIntersection(S,E,clipedge))\;
}
S = E\;
}
}
}
return output\;
\caption{Sutherland-Hodgman pseudo algorithm. Adapted from \cite{wiki:polygonclip}.}
\label{alg:polyclip}
\end{algorithm}

After detecting that an overlap occurs, the algorithm calculates the area of the polygon, which describes the overlap, to determine the energy of the current configuration, the overlapping area is calculated using the Sutherland-Hodgman Clipping algorithm~\cite{sutherland1974reentrant}. This algorithm finds the vertices of the intersection polygon created by the two triangles. The overlap can be described as a polygon, it can be either be defined at least as a triangle, see Figure \ref{fig:overlap1}, or a polygon with a degree, see Figure \ref{fig:overlap2}, depending on how the triangles overlap each otherr. Algorithm \ref{alg:polyclip} shows the pseudocode for the Sutherland-Hodgman Clipping algorithm, where the input is two polygons, in our case, the two triangles that intersect. The vertices list resulting from this algorithm can be used to calculate the area using the shoelace formula~\cite{vslapak2017automated}, see formula \ref{eq:shoelace} where $x_i$ and $y_i$ are the coordinates of the $i$-th point in P. It is a mathematical algorithm to calculate the area of a simple polygon, that is described by ordered points $P$ in a plane.

\begin{equation}
Area = \frac{1}{2} \left| \sum_{i=0}^{P-1} x_iy_{i+1} + x_ny_1 - \sum_{i=1}^{n-1} x_{i+1}y_i - x_1y_n \right|
\label{eq:shoelace}
\end{equation}

\chapter{Implementation}
\label{chap:Implementation}

\section{Specifications}

The prototype is implemented on a Laptop with an Intel Core i7 CPU (3.3 GHz, 4MB Cache) and 8GB RAM. The source code is written in C++17 and the OpenGL Library library is used for the visualization of the algorithms step as well as the results. The CGAL library is used to read in off-Files as well as the underlying data structure. The Graphical User Interface (GUI) is developed using the Qt Library. CMake is used to manage the build process, and it compiles on an Ubuntu 18.04.02 LTS operating system.

\section{Simmulated Annealing}

The four important ingredients to use a simulated annealing process, explained in section \ref{sec:sa}, are defined for the following way.
\begin{itemize}
	\item \textbf{System Description} The system configuration is described as a list of edges that will be bent and the complementary list of edges that are cut. Furthermore the facets attached to the edges, as well as the gluetags attached to some of the cut edges.
	\item \textbf{Random Move} To alter the configuration randomly, a random edge of the full eedge list has its weight changed, therefore the minimum spanning tree that is calculated changes.
	\item \textbf{Quantitive Function} To evaluate the system configuration the sum of the overlapping areas is used.
	\item \textbf{Annealing Schedule} The temperature is set to 50.000 as a standard, but can be configured and the cooling rate is set to 1.0, therefore the temperature equals the amount of iterations.
\end{itemize}

After reading in the mesh into the CGAL Polyhedron\_3 data structure preparations are necessary to be able to describe the system. First, the algorithm calculates a dual graph and Gluetags, for each edge of the dual graph, as each edge could be a possible cut edge. Furthermore, it sets the temperature, and the cooling rate to 50.000 and 1.0 per iteration, defining the runtime of the annealing process.

The algorithm assigns each edge of the dual graph a random weight and then sorts the list. Then it calculates an initial spanning tree using the edge list. Glue tags are calculated for all edges that will be cut, which are the edges not present in the minimum spanning tree. The algorithm iterates through all possible Gluetags and chooses a Gluetag if they fulfil the following conditions:

\begin{itemize}
	\item The edge the gluetag is attached to is a cut edge
	\item The opposite gluetag was not already added to this edge
	\item The number of cut edges, that have no gluetag yet is higher than 1 or neither the source face for the gluetag nor the the face the gluetag targets have a gluetag yet
\end{itemize}

The algorithm discards all Gluetags that do not fulfil these conditions, as they are not needed for this unfolding. These conditions ensure that the reconstructed model will be stable when glued together without faces being loose, but they also minimize the number of Gluetags to reduce time and effort on reconstruction.

After these steps, the algorithm starts unfolding the triangles and the Gluetags alike. It calculates the area of both triangle-triangle overlaps, Gluetag-triangle overlaps and Gluetag-Gluetag overlaps. This approach proposes to weigh triangle-triangle overlaps with a factor of 100, so the algorithm prefers to unfold triangles without overlaps first and afterwards solving Gluetag related overlaps. This step is used to optimize the calculation time as well as to influence the evolving graph. The algorithm focuses more on the resolve of triangles, as their overlap area is higher weighted. It is done because a configuration that does not have any Gluetag overlaps, but still has triangle overlaps is less optimal than the other way around. If no triangle-triangle overlaps occur in a configuration and only Gluetags overlap are left, these have a chance to be resolved for example by changing which Gluetags are used or by post processing the size of the gluetags.

The calculated area is then used as the energy of the graph, which we try to minimize in this process. This initial configuration is saved as the best configuration. For each following iteration before these steps are repeated a random edge will be chosen and assigned to a new random weight, which possibly changes the outcoming minimum spanning tree. In the iterative generations and evaluation of configurations also the calculation of the energy differs. 

First, the algorithm unfolds the triangles and evaluates the energy of the graph based on the sum of the overlapping area. If and only if the triangles are unfolded without overlaps, it unfolds the Gluetags next. This approach saves computation time, as if the triangles do not unfold without overlaps, no solution is found.

If the energy of the new configuration is smaller or equal to the energy of the previous configuration, the new configuration will be set as the best configuration. If not the configuration is treated probabilistically. If a uniformly distributed random number is smaller than $P(\Delta E) = 1 - e^{-(T + E)/(T_{max})}$ the new configuration will be accepted as the best configuration. This condition should ensure that the algorithm does not get stuck in a local minimum, which would mean that it would not find an optimal global solution.

At the end of every iteration, if a new best configuration was found the new configuration will be visualized using OpenGL, which means that it only changes and impacts calculation time of each iteration if a better configuration was found. 

The annealing process ends if it does not find any overlaps or if the temperature reaches the minimum, which means that it ends without finding a solution for this problem. Advantages and Disadvantages using this random walk approach will be discussed in section \ref{sec:limitations}.

\section{Parameterization}
The algorithm is optimizable by changing multiple parameters without changing the approach itself.

\textbf{Gluetag size} is the most influential parameter that can be changed. Depending on the size of the Gluetag, the solution space is widened or made smaller if the Gluetags area increases.

\textbf{Probabilistic treatment of worse iterations} can also be changed to either favour taking a worse iteration more or less often. If the probability is too high to take a worse iteration, the algorithm will not find a solution and might not even get close to a solution if the probability is too low, the chance of getting stuck in local minimums increases.

\textbf{Number of iteration} can be controlled by changing the cooling down rate as well as the maximum and minimum temperature, therefore changing the time the algorithm has to find a solution.

By tuning these parameters, the results can be influenced to get better performance or make finding an even unfolding possible.

\chapter{Results and Evaluation}
\label{chap:reseval}

\section{Results}
The following figures show the resulting unfolding of the implementation. The Gluetags are visualized in the 3D-Model and the unfolding, furthermore, the minimum spanning tree (green lines) and cut-edges (red lines) are visualized in the 3D-Model.

\begin{figure}
  \begin{subfigure}[b]{0.5\textwidth}
    \includegraphics[width=\textwidth]{"graphics/unfoldings/model_tiger"}
  \end{subfigure}
  %
  \begin{subfigure}[b]{0.5\textwidth}
    \includegraphics[width=\textwidth]{"graphics/unfoldings/unfold_tiger"}
  \end{subfigure}
  
  \caption{3D Model of a tiger head with 112 faces and the coresponding unfolding.}
  \label{fig:tiger}
\end{figure}

\begin{figure}
  \begin{subfigure}[b]{0.5\textwidth}
    \includegraphics[width=\textwidth]{"graphics/unfoldings/model_sqrt3"}
  \end{subfigure}
  %
  \begin{subfigure}[b]{0.5\textwidth}
    \includegraphics[width=\textwidth]{"graphics/unfoldings/unfold_sqrt3"}
  \end{subfigure}
  
  \caption{3D Model with 72 faces and the coresponding unfolding.}
  \label{fig:sqrt3}
\end{figure}

\begin{figure}
  \begin{subfigure}[b]{0.5\textwidth}
    \includegraphics[width=\textwidth]{"graphics/unfoldings/model_pnsplit"}
  \end{subfigure}
  %
  \begin{subfigure}[b]{0.5\textwidth}
    \includegraphics[width=\textwidth]{"graphics/unfoldings/unfold_pnsplit"}
  \end{subfigure}
  
  \caption{3D Model of a star with 216 faces and the coresponding unfolding.}
  \label{fig:pnsplit}
\end{figure}

\begin{figure}
  \begin{subfigure}[b]{0.5\textwidth}
    \includegraphics[width=\textwidth]{"graphics/unfoldings/model_loop"}
  \end{subfigure}
  %
  \begin{subfigure}[b]{0.5\textwidth}
    \includegraphics[width=\textwidth]{"graphics/unfoldings/unfold_loop"}
  \end{subfigure}
  
  \caption{3D Model of a star with 96 faces and the coresponding unfolding.}
  \label{fig:loop}
\end{figure}

\begin{figure}
  \begin{subfigure}[b]{0.5\textwidth}
    \includegraphics[width=\textwidth]{"graphics/unfoldings/model_butterfly"}
  \end{subfigure}
  %
  \begin{subfigure}[b]{0.5\textwidth}
    \includegraphics[width=\textwidth]{"graphics/unfoldings/unfold_butterfly"}
  \end{subfigure}
  
  \caption{3D Model of a star with 96 faces and the coresponding unfolding.}
  \label{fig:butterfly}
\end{figure}

\begin{figure}
  \begin{subfigure}[b]{0.5\textwidth}
    \includegraphics[width=\textwidth]{"graphics/unfoldings/model_dragon"}
  \end{subfigure}
  %
  \begin{subfigure}[b]{0.5\textwidth}
    \includegraphics[width=\textwidth]{"graphics/unfoldings/unfold_dragon"}
  \end{subfigure}
  
  \caption{3D Model of a dragon with 344 faces and the coresponding unfolding.}
  \label{fig:dragon}
\end{figure}

\begin{figure}
  \begin{subfigure}[b]{0.5\textwidth}
    \includegraphics[width=\textwidth]{"graphics/unfoldings/model_horse"}
  \end{subfigure}
  %
  \begin{subfigure}[b]{0.5\textwidth}
    \includegraphics[width=\textwidth]{"graphics/unfoldings/unfold_horse"}
  \end{subfigure}
  
  \caption{3D Model of a horse with 312 faces and the coresponding unfolding.}
  \label{fig:horse}
\end{figure}

\begin{figure}
  \begin{subfigure}[b]{0.5\textwidth}
    \includegraphics[width=\textwidth]{"graphics/unfoldings/model_hand"}
  \end{subfigure}
  %
  \begin{subfigure}[b]{0.5\textwidth}
    \includegraphics[width=\textwidth]{"graphics/unfoldings/unfold_hand"}
  \end{subfigure}
  
  \caption{3D Model of a hand with 336 faces and the coresponding unfolding.}
  \label{fig:hand}
\end{figure}

\begin{figure}
  \begin{subfigure}[b]{0.5\textwidth}
    \includegraphics[width=\textwidth]{"graphics/unfoldings/model_armadillo"}
  \end{subfigure}
  %
  \begin{subfigure}[b]{0.5\textwidth}
    \includegraphics[width=\textwidth]{"graphics/unfoldings/unfold_armadillo"}
  \end{subfigure}
  
  \caption{3D Model of an armadillo with 386 faces and the coresponding unfolding.}
  \label{fig:armadillo}
\end{figure}

\section{Performance}
\label{sec:performance}

To evaluate the algorithm and its implementation tests were run with a variety of models. The results in table \ref{tbl:performance} were observed using a Gluetag that is defined as a trapezoid with the base being the edge of the to-glue triangles and the top being one half of the base with a maximum height of one-fifth of the size of the triangle being targeted by the Gluetag. The iterations are capped at a maximum of 100000.

\begingroup
\centering
\begin{tabular}{|ll|r|r|}
\hline
Model & & Faces & Time to Unfold (s) \\
\hline
Octa & & 8 & 0 \\
Icosa & & 20 & 0 \\
Star & & 24 & 8 \\
%Sphere-42 & & 42 & - \\
Star-Sqrt3 & (Fig. \ref{fig:sqrt3}) & 72 & 31 \\
Star-4Split & & 96 & 435 \\
Star-Loop & (Fig. \ref{fig:loop}) & 96 & 137 \\
Star-Butterfly & (Fig. \ref{fig:butterfly}) & 96 & 1047 \\
Tiger & (Fig. \ref{fig:tiger}) & 112 & 65 \\
Kitten & & 122 & 48 \\
Moneybox-128 & & 128 & 160 \\
Bunny-128 & & 128 & 103 \\
%Sphere-162 & & 162 & - \\
Moneybox-196 & & 196 & 324 \\
%Star-9Split & & 216 & - \\
Star-PNsplit & (Fig. \ref{fig:pnsplit}) & 216 & 625 \\
Snail-286 & & 286 & 1315 \\
Horse & (Fig. \ref{fig:horse}) & 312 & 946 \\
Hand & (Fig. \ref{fig:hand}) & 336 & 1377 \\
Dragon & (Fig. \ref{fig:dragon}) & 344 & 1292 \\
Bunny-348 & & 348 & 976 \\
Luigi & & 356 & 686 \\
Armadillo & (Fig. \ref{fig:armadillo}) & 386 & 730 \\
Pooh & & 392 & 957 \\
Moneybox-392 & & 392 & 2200 \\
%Seagull & & 462 & - \\
%Knot & & 480 & - \\
%Chess & & 496 & - \\
Gear & & 508 & - \\
%Bumpy & & 528 & - \\
%Snail-574 & & 574 & - \\
Cat & & 702 & - \\
Fish & & 950 & - \\
Mannequin & & 1376 & - \\
\hline
\end{tabular}
\captionof{table}{Table showing the unfolding performance for different models}\label{tbl:performance}
\endgroup

Performance is not only influenced by the number of faces, but also by the size of Gluetags. The bigger the Gluetags are, the more iterations are necessary to find an unfolding, or an unfolding might no longer be possible. Due to the random walk, the time to find an unfolding is not depending on the number of faces. Table \ref{tbl:performance} shows that not only the number of faces influence the time it takes to find a solution, but it also depends on how and which edges are changed. For models marked with a - in the table \ref{tbl:performance} no unfolding was found within 100000 iterations.

\section{Limitations}
\label{sec:limitations}

Multiple factors limit the suggested approach. The target of the approach is to solve the problem only considering the global optimum, disregarding local overlaps. Therefore the latter are hard to resolve, as they are not explicitly targeted.

Another limitation is that the Gluetags that are necessary cannot be calculated beforehand. Neither the amount nor the position of the Gluetags can be calculated, without using a heuristic approach or brute force, whereas brute force is not feasible as the performance even with small models is abysmal.

Another limitation that does not have only negative consequences is the random-walk approach used in the simulated annealing. A random edge is chosen and changed in each iteration, which might not change the minimum spanning tree that is generated. It can happen that an edge that is causing an overlap does not change for many iterations.

\chapter{Conclusion}
\label{chap:conclusion}

\section{Summary}
Calculating an unfolding using a minimum spanning tree approach is possible and can yield excellent performance for smaller meshes. As meshes have increased numbers of faces and Gluetags increase in size, the worse the algorithm is performing. The reconstruction is almost impossible without any visual cues on which edges should be folded or glued first, but disregarding this factor as it can be added with this approach too, a more significant setback is that the unfolding is more or less random and structures of the 3D-Model might not be well conserved into the unfolding. All in all, the approach is simple to implement as no sophisticated algorithms are needed, and it yields results in an acceptable amount of time for models with less than 200 faces.

\section{Future Work}
The quality of the unfolding could be improved, by not only measuring the unfolding by the overlap area but also considering other factors, like keeping structures of the mesh together to help users with reconstructing the models.

Performance can be improved, if Gluetags are post-processed to change their shape if the overlap area is rather small. With this improvement, the computation time can be reduced significantly, without impacting other parts of the approach.

Once an unfolding with Gluetags for a model is found, a greedy algorithm could be used to minimize the number of Gluetags necessary. Currently, the amount of Gluetags is determined by the order the Gluetags are added. Therefore it can result in using more Gluetags than necessary for the particular unfolding.
\backmatter

% Use an optional list of figures.
\listoffigures % Starred version, i.e., \listoffigures*, removes the toc entry.

% Use an optional list of tables.
\cleardoublepage % Start list of tables on the next empty right hand page.
\listoftables % Starred version, i.e., \listoftables*, removes the toc entry.

% Use an optional list of alogrithms.
\listofalgorithms
\addcontentsline{toc}{chapter}{List of Algorithms}

% Add an index.
\printindex

% Add a glossary.
\printglossaries

% Add a bibliography.
\bibliographystyle{alpha}
\bibliography{meshunfolding}

\end{document}
